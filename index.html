<!doctype html>
<html lang="th">
<head>
<meta charset="utf-8">
<title>Wave Shooter — Easy Physics</title>
<style>
  body{margin:0;font-family:"Comic Sans MS","Noto Sans Thai",sans-serif;background:#a7d9f7;color:#333;text-align:center}
  canvas{background:#dff6ff;display:block;margin:0 auto;border-radius:12px}
  h1{margin:10px 0;color:#ff6fa8}
  #controls{margin:12px}
  .btn{padding:10px 16px;margin:6px;border:none;border-radius:8px;font-weight:bold;cursor:pointer}
  .correct{background:#8df59a}
  .wrong{background:#f7a4a4}
  .hud{margin:10px;font-size:18px}
</style>
</head>
<body>
<h1>Wave Shooter — λ · f · v</h1>
<canvas id="c" width="800" height="300"></canvas>
<div class="hud">
  <span>Score: <span id="score">0</span></span> |
  <span>Lives: <span id="lives">5</span></span> |
  <span>f = <span id="fDisplay">10</span> Hz</span>
</div>
<div id="controls"></div>
<script>
const canvas=document.getElementById("c");
const ctx=canvas.getContext("2d");
const W=canvas.width,H=canvas.height;

let score=0,lives=5;
let f=10; // เริ่มต้นความถี่
let currentEnemy=null;
let answered=false, totalDefeated=0;

// เอฟเฟกต์
let waves=[];   // เก็บคลื่นยิง
let explosions=[]; // เก็บระเบิด

function newEnemy(){
  answered=false;
  const v=100*(1+Math.floor(Math.random()*5));
  const lambda=v/f;
  currentEnemy={x:W-50,y:H/2,v,lambda,alive:true};
  makeChoices(lambda);
}

function makeChoices(correct){
  const container=document.getElementById("controls");
  container.innerHTML="";
  let choices=[correct];
  while(choices.length<3){
    let wrong=correct+(Math.floor(Math.random()*5)-2)*5;
    if(wrong<=0) continue;
    if(!choices.includes(wrong)) choices.push(wrong);
  }
  choices.sort(()=>Math.random()-0.5);
  for(let val of choices){
    const btn=document.createElement("button");
    btn.textContent="λ = "+val+" m";
    btn.className="btn";
    btn.onclick=()=>checkAnswer(val,correct,btn);
    container.appendChild(btn);
  }
}

function checkAnswer(val,correct,btn){
  if(answered) return;
  answered=true;
  if(val===correct){
    btn.classList.add("correct");
    score+=50;
    totalDefeated++;
    // ยิงคลื่น
    fireWave();
    setTimeout(()=>{
      if(totalDefeated%5===0){
        f=[10,20,25,50][(totalDefeated/5)%4]||10;
      }
    },1000);
  }else{
    btn.classList.add("wrong");
    score-=10;
  }
  updateHUD();
}

function fireWave(){
  waves.push({
    x:100, y:H/2, t:0, speed:6
  });
}

function explode(x,y){
  for(let i=0;i<10;i++){
    explosions.push({
      x,y, r:2, dx:(Math.random()-0.5)*4, dy:(Math.random()-0.5)*4
    });
  }
}

function updateHUD(){
  document.getElementById("score").textContent=score;
  document.getElementById("lives").textContent=lives;
  document.getElementById("fDisplay").textContent=f;
}

function gameOver(){
  ctx.fillStyle="rgba(0,0,0,0.5)";
  ctx.fillRect(0,0,W,H);
  ctx.fillStyle="#fff";
  ctx.font="28px Comic Sans MS";
  ctx.fillText("Game Over!",W/2-80,H/2);
}

function loop(){
  ctx.clearRect(0,0,W,H);

  // ปืน
  ctx.fillStyle="#ffb347";ctx.fillRect(40,H/2-20,40,40);
  ctx.fillStyle="#ff6fa8";ctx.fillRect(80,H/2-10,30,20);

  // ศัตรู
  if(currentEnemy && currentEnemy.alive){
    currentEnemy.x-=W/200/20;
    ctx.fillStyle="#a77dff";
    ctx.beginPath();ctx.arc(currentEnemy.x,currentEnemy.y,20,0,Math.PI*2);ctx.fill();
    ctx.fillStyle="#333";ctx.font="14px Comic Sans MS";
    ctx.fillText("v="+currentEnemy.v+" m/s",currentEnemy.x-30,currentEnemy.y-30);
    if(currentEnemy.x<90){
      lives--;
      updateHUD();
      newEnemy();
      if(lives<=0){gameOver();return;}
    }
  }

  // คลื่น
  for(let wv of waves){
    wv.x+=wv.speed;
    wv.t+=0.2;
    ctx.beginPath();
    ctx.moveTo(wv.x-60,wv.y);
    for(let i=0;i<60;i++){
      let xx=wv.x+i;
      let yy=wv.y+Math.sin((i+wv.t)/5)*10;
      ctx.lineTo(xx,yy);
    }
    ctx.strokeStyle="#00c4ff";
    ctx.lineWidth=2;
    ctx.stroke();
    // ชนศัตรู
    if(currentEnemy && currentEnemy.alive && wv.x>currentEnemy.x-20){
      currentEnemy.alive=false;
      explode(currentEnemy.x,currentEnemy.y);
      setTimeout(()=>newEnemy(),800);
    }
  }

  // เอฟเฟกต์ระเบิด
  explosions.forEach(ex=>{
    ex.x+=ex.dx; ex.y+=ex.dy; ex.r+=0.5;
    ctx.beginPath();
    ctx.arc(ex.x,ex.y,ex.r,0,Math.PI*2);
    ctx.fillStyle="rgba(255,255,0,0.6)";
    ctx.fill();
  });

  requestAnimationFrame(loop);
}
updateHUD();
newEnemy();
loop();
</script>
</body>
</html>

